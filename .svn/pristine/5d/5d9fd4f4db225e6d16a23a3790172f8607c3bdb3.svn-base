import {Injectable} from '@angular/core';
import {Platform} from 'ionic-angular';
import 'rxjs/add/operator/map';
import {ApiService} from './api-service';
//import {StorageService} from './storage-service';
import {UserManager} from './user-manager';
import {Utils} from '../utils/utils';


@Injectable()
export class TaskManager {


    currentUser: any;
    currentTask: any;
    tomorrowsTask: any;
    taskStatuses: any = {};
    badgeNumber: any = 0;
    holdObject: any = {};
    hasToken: any;


    constructor(public userMgr: UserManager,
                public apiService: ApiService,
                private platform: Platform,
                private utils: Utils) {
    }

    //  * method for creating a taskUserlog and handling response and errors
    createTaskUserLog(postData) {
        return new Promise((resolve, reject) => {
            this.apiService.postTaskFeedback(postData).then((response) => {
            }).catch(error => {
                reject({error: true, msg: 'An error has occurred submitting your information', raw: error});
            })
        })
    }

    updateEmployeeToken(newToken) {
        return new Promise((resolve, reject) => {
            let user = this.userMgr.getUser();
            let data = {
                userId: user.userId,
                token: newToken
            };
            this.apiService.updateEmployeeToken(data).then(response => {
                this.hasToken = response;
                resolve(this.hasToken);
            }).catch(error => {
                reject(error);
            })
        })
    }

    //  * gets current task for logged in user
    //  * then gets the taskUserLog for the task
    //  * @Returns: Promise:any
    getCurrentTaskRemote() {
        let currentTaskResponse: any;
        return new Promise((resolve, reject) => {
            let user = this.userMgr.getUser();
            let data = {userId: user.userId};
            this.apiService.loadCurrentTask(data).then(response => {
                let task: any = response;
                currentTaskResponse = {
                    "task": task.data.hasOwnProperty('id') ? task.data : null,
                    "user": user
                };
                this.currentTask = task.data;
                if (this.currentTask.job_tasks) {
                    Number(this.currentTask.job_tasks.task_start_time);
                }
                this.currentUser = user;
                // have we received a task? //
                if (task.data.hasOwnProperty('id')) {
                    // load the task user log
                    return this.loadTaskUserLog();
                } else {
                    //no task found
                    reject()
                }
            }).then(response => {
                let json: any = response;
                currentTaskResponse.task.job_tasks.task_user_log = json.data;
                resolve(currentTaskResponse);
            }).catch(error => {
                reject(error);
            })
        })
    };

    loadNextDayTask() {
        let nextDayTaskResponse: any;
        return new Promise((resolve, reject) => {
            let user = this.userMgr.getUser();
            //let token = this.userMgr.getToken();
            let data = {userId: user.userId};
            this.apiService.loadNextDayTask(data).then(response => {
                let task: any = response;
                nextDayTaskResponse = {
                    "task": task.data,
                    "user": user
                };
                this.tomorrowsTask = task;
                if (this.tomorrowsTask.job_tasks) {
                    Number(this.tomorrowsTask.job_tasks.task_start_time);
                }
                this.currentUser = user;
            })
                .then(response => {
                    resolve(nextDayTaskResponse);
                }).catch(error => {
                reject(error);
            })
        })
    };


    //  * call to loadTaskUserLog
    loadTaskUserLog() {
        let data: any = {
            "userId": this.currentUser.userId,
            "taskId": this.currentTask.job_tasks.id
        };
        return this.apiService.loadTaskUserLog(data);
    }

    loadSpecificTaskUserLog(empId, taskId) {
        let data: any = {
            "userId": empId,
            "taskId": taskId
        };
        return this.apiService.loadTaskUserLog(data);
    }

    //  * call to loadTaskUserLog
    loadTaskUserLogArray(taskID) {
        let data: any = {
            "userId": this.currentUser.userId,
            "taskId": taskID
        };
        return this.apiService.loadTaskUserNotes(data);
    }

    checkEmployeeAlerts() {
        let newUserId = this.userMgr.getUserId();
        return new Promise((resolve, reject) => {
            let demo = {
                'userId': newUserId,
            };
            let num = 0;
            //make the api request
            this.apiService.checkEmployeeAlerts(demo).then(response => {
                this.holdObject = response;
                this.badgeNumber = this.holdObject.data.new_alert_count;
                resolve(response);
                return num;
            }).catch(error => {
                reject({msg: 'Unable to load Alerts'})
            })
        });
    }

    numOfNewAlerts(alerts) {
        let data = alerts.data;
        let num = 0;
        for (let i in data) {
            if (data[i].viewed === 0) {
                num += 1;
            }
        }
        this.badgeNumber = num;
        return num;
    }

    getEmployeeAlerts() {
        return new Promise((resolve, reject) => {
            if (this.currentUser && this.currentUser.userId) {
                //donothing
            } else {
                reject({msg: 'Unable to load Alerts'})
            }
            let data = {
                'userId': this.currentUser.userId,
                'dateStart': new Date((Date.now() - 259200000)),
                'dateEnd': new Date((Date.now() + 86400000))
            };
            console.log("start " + data.dateStart);
            console.log("end " + data.dateEnd);
            this.apiService.loadEmployeeAlerts(data).then(response => {
                this.numOfNewAlerts(response);
                resolve(response);
            }).catch(error => {
                reject({msg: 'Unable to load Alerts'})
            })
        });
    }

    markEmployeeAlertRead = (data: any): Promise<any> => {
        return new Promise((resolve, reject) => {
            this.apiService.markEmployeeAlertRead(data).then(response => {
                resolve(response);
            }).catch(error => {
                reject({msg: 'Unable to load history'})
            })
        })
    };

    //  * gets the remote task history
    //  * @Returns: Promise
    getTaskHistoryRemote(userId) {
        let task: any;
        return new Promise((resolve, reject) => {

            let data = {
                'userId': userId,
                'dateStart': new Date((Date.now() - 432000000)),
                'dateEnd': new Date(Date.now() + 86400000)
            };

            console.log("Date Check " + data.dateStart);

            this.apiService.loadTaskHistory(data).then(response => {
                task = response;
            }).then(response => {
                resolve(task);
            }).catch(error => {
                reject({msg: 'Unable to load history'})
            })
        });
    }

    loadNextDayTaskByDate(userId) {
        this.currentUser = this.userMgr.getUser();
        let task: any;
        return new Promise((resolve, reject) => {

            let data = {
                'userId': userId
            };

            console.log('data', JSON.stringify(data));

            this.apiService.loadNextDayTaskByDate(data).then(response => {
                task = response;
            }).then(response => {
                resolve(task);
            }).catch(error => {
                reject({msg: 'Unable to load history'})
            })
        });
    }

    loadLaborerTasks(userId) {
        let task: any;
        return new Promise((resolve, reject) => {
            let data = {
                'userId': userId
            };
            this.apiService.loadLaborerTasks(data).then(response => {
                task = response;
            }).then(response => {
                resolve(task);
            }).catch(error => {
                reject({msg: 'Unable to load history'})
            })
        });
    }

    loadForemanTasks() {
        let task: any;
        return new Promise((resolve, reject) => {
            if (this.currentUser && this.currentUser.userId) {
                //donothing
            } else {
                reject({msg: 'Unable to load history'})
            }
            let data = {
                'userId': this.currentUser.userId
            };

            this.apiService.loadForemanTasks(data).then(response => {
                task = response;
            }).then(response => {
                resolve(task);
            }).catch(error => {
                reject({msg: 'Unable to load history'})
            })
        });
    }

    // authenticate user and handles response //
    authenticateUser() {
        return new Promise((resolve, reject) => {
            //resolve(this.tmpData.data.authenticateUser);
            this.apiService.authenticate({}).then(json => {
                resolve(json);
            }).catch(error => {
                console.log(`ERROR: ${Utils.toJson(error)}`);
                // this.utils.toastError(error);
                reject(error);
            })
        });
    }

    // gets the task statuses //
    getTaskStatuses(filterStatus ?: boolean, systemOnly ?: boolean) {
        return this.taskStatuses;
    }

    //  * get the feedback statuses
    getFeedbackStatuses() {
        this.taskStatuses.filter((status) => {
            return status.id
        })
    }

    // helper method to make some of the promise code a little cleaner //
    resolveAsPromise = (obj: any): Promise<any> => {
        return new Promise((resolve, reject) => {
            resolve(obj);
        })
    };

    //  * just calls api.postTaskFeedback, no image uploading
    updateNextDayTaskStatus = (data: any): Promise<any> => {
        data.userId = this.userMgr.getUser().userId;
        return new Promise((resolve, reject) => {
            let myMessage = "success";
            this.apiService.postTaskFeedback(data).then((json) => {
                let response: any = JSON.parse(JSON.stringify(json));
                if (response.code != 0) {
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    return this.resolveAsPromise(false);
                } else if (data.statusId === 3) {
                    return myMessage;
                } else if (data.statusId === 8) {
                    return myMessage;
                } else if (data.statusId === 9) {
                    return myMessage;
                } else {
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    resolve(false);
                }
            }).then(response => {
                resolve(response);
            });
        })
    };

    //  * just calls api.postTaskFeedback, no image uploading
    updateTaskStatus = (data: any): Promise<any> => {
        console.log("step 5 - update task status  " + JSON.stringify(data));
        data.userId = this.userMgr.getUser().userId;
        data.taskId = this.currentTask.job_tasks.id;
        return new Promise((resolve, reject) => {
            this.apiService.postTaskFeedback(data).then((json) => {
                let response: any = JSON.parse(JSON.stringify(json));
                console.log("step 7 return trip  " + JSON.stringify(response));
                if (response.code != 0) {
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    return this.resolveAsPromise(false);
                } else if (data.statusId === 3) {
                    // ACCEPTED //
                    this.currentTask.statusId = 3;
                    // get current task and log //
                    return this.currentTask
                } else if (data.statusId === 4) {
                    // STARTED //
                    this.currentTask.statusId = 4;
                    // get current task and log //
                    return this.currentTask;
                } else if (data.statusId === 5) {
                    // DELAYED //
                    this.currentTask.statusId = 5;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 6) {
                    // ON HOLD //
                    this.currentTask.statusId = 6;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 7) {
                    // EMERGENCY //
                    this.currentTask.statusId = 7;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 8) {
                    // REJECTED //
                    this.currentTask.statusId = 8;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 9) {
                    // COMPLETED //
                    this.currentTask.statusId = 9;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 12) {
                    // COMPLETED //
                    this.currentTask.statusId = 12;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else if (data.statusId === 13) {
                    // COMPLETED //
                    console.log("step 8 inside else if 13 ");
                    console.log('this.currentTask', JSON.stringify(this.currentTask));
                    this.currentTask.statusId = 13;
                    // get current task and log //
                    return this.resolveAsPromise(this.currentTask);
                } else {
                    // UNKNOWN statusId //
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    resolve(false);
                }
            }).then(response => {
                console.log(`postFeedbackImages Response => ${Utils.toJson(response)}`);
                resolve(response);
            });
        })
    };

    //  * just calls api.postTaskFeedback, no image uploading
    resumeOnHoldTask = (data: any): Promise<any> => {
        return new Promise((resolve, reject) => {
            this.apiService.postTaskFeedback(data).then((json) => {
                let response: any = JSON.parse(JSON.stringify(json));
                if (response.code != 0) {
                    //something happened, show a toast :)
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    //resolve(false);
                    return this.resolveAsPromise(false);
                } else if (data.statusId === 4) {
                    // ACCEPTED //
                    this.currentTask.statusId = 4;
                    // get current task and log //
                    return this.currentTask
                } else {
                    // UNKNOWN statusId //
                    let msg = `Could not update task status: ${response.msg}`;
                    this.utils.presentToast(msg, true, 'X');
                    resolve(false);
                }
            }).then(response => {
                console.log(`postFeedbackImages Response => ${Utils.toJson(response)}`);
                resolve(response);
            });
        })
    };

    /**
     * posts feedback with images
     * @Input: feedback object
     */
    postFeedback(feedback: any) {
        // add current user id and current task id to feedback object //
        feedback.userId = this.userMgr.getUser().userId;
        feedback.taskId = this.currentTask.job_tasks.id;
        //call the api //
        return new Promise((resolve, reject) => {
            this.apiService.postTaskFeedback(feedback).then((response) => {
                let r: any = response;
                return this.postFeedbackImages(r.msg, feedback.files);
            }).then(response => {
                resolve(true);
            });
        })
    }

    postHistoryFeedback(feedback: any) {
        // add current user id and current task id to feedback object //
        feedback.userId = this.userMgr.getUser().userId;
        console.log('feedback', JSON.stringify(feedback));
        // feedback.taskId = this.currentTask.job_tasks.id;
        //call the api //
        return new Promise((resolve, reject) => {
            this.apiService.postTaskFeedback(feedback).then((response) => {
                let r: any = response;
                return this.postFeedbackImages(r.msg, feedback.files);
            }).then(response => {
                resolve(true);
            });
        })
    }


    // * calls the api to post feedback images
    postFeedbackImages(feedbackId, images) {
        let promises = [];
        if (images.length == 0) {
            return new Promise((resolve, reject) => {
                resolve(true);
            })
        } else {
            for (let i = 0; i < images.length; i++) {
                if (this.platform.is('cordova')) {
                    promises.push(this.apiService.postTaskFeedbackImageNative(feedbackId, images[i]))
                } else {
                    promises.push(this.apiService.postTaskFeedbackImage(feedbackId, images[i]))
                }
            }
            return Promise.all(promises)
        }
    }

    resetPassword(userEmail) {
        this.apiService.sendPasswordReset({email: userEmail}).then((response: any) => {
            if (response.code === 0) {
                let msg = "An email has been sent to " + userEmail;
                this.utils.presentToast(msg, true, 'OK');
                this.utils.dismissLoading();
            } else {
                let msg = " " + userEmail + " is not a valid email address ";
                this.utils.presentToast(msg, true, 'OK');
                this.utils.dismissLoading();
            }
        })
    }

    createTimecardEntry(empId, inLat, inLon, myStatus, inNotes?: any) {
        return new Promise((resolve, reject) => {
            let data = {
                employee_id: empId,
                lat: inLat,
                lon: inLon,
                status: myStatus,
                notes: inNotes
            };

            this.apiService.createTimecardEntry(data).then(response => {
                console.log("a new entry has been created");
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }

    createNewTimecardEntry(empId, myStatus, altTime, inNotes?: any) {
        return new Promise((resolve, reject) => {
            let data = {
                employee_id: empId,
                alt_timestamp: altTime,
                status: myStatus,
                notes: inNotes || "NULL"
            };

            this.apiService.createTimecardEntry(data).then(response => {
                console.log("a new entry has been created");
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }

    loadTodaysTime(empId) {
        return new Promise((resolve, reject) => {
            let data = {
                employee_id: empId,
                'dateStart': new Date(Date.now()),
                'dateEnd': new Date(Date.now() + 86400000)
            };

            console.log(data.dateStart);

            this.apiService.loadTimecardData(data).then(response => {
                console.log("a new entry has been created");
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }

    updateTimecard(empId, timecardId, updatedTime, notes) {
        return new Promise((resolve, reject) => {
            let data = {
                'employee_id': empId,
                'id': timecardId,
                'alt_timestamp': updatedTime,
                'notes': notes
            };


            this.apiService.updateTimecard(data).then(response => {
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }

    timecardSearch(empId, start, end) {
        return new Promise((resolve, reject) => {
            let data = {
                employee_id: empId,
                'dateStart': start,
                'dateEnd': end
            };

            console.log(data.dateStart);

            this.apiService.loadTimecardData(data).then(response => {
                console.log("a new entry has been created");
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }

    deleteTimecardEntry(empId, entryId) {
        return new Promise((resolve, reject) => {
            let data = {
                employee_id: empId,
                id: entryId

            };

            console.log('data in task manager ', JSON.stringify(data));

            this.apiService.makeTimecardEntryInactive(data).then(response => {
                console.log("That is now inactive");
                resolve(response)
            }).catch(error => {
                console.log('error updating timecard');
                reject(error);
            })
        })
    }
}
