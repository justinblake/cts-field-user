import {Component, ViewChild, Pipe, PipeTransform} from '@angular/core';
import {HardwareBackButtonService} from '../../providers/backbutton';
import {NavController, App, Modal, Platform, Content, AlertController} from 'ionic-angular';
import {CallNumber} from '@ionic-native/call-number';
import {DrivingDirectionsPage} from '../driving-directions/driving-directions';
import {AndroidFullScreen} from '@ionic-native/android-full-screen';
import {LoginPage} from '../login/login';
import {FeedbackPage} from '../feedback/feedback';
import {GoogleMapsManager} from '../../providers/google-maps-manager';
import {Geolocation} from '@ionic-native/geolocation';
import {TaskManager} from '../../providers/task-manager';
import {UserManager} from '../../providers/user-manager';
import {Utils} from '../../utils/utils';
import {Animations} from '../../animations/animations';
import {Push, PushToken} from '@ionic/cloud-angular';
import {AlertsPage} from "../alerts/alerts";
import {Diagnostic} from '@ionic-native/diagnostic';
import {NextDayPage} from '../next-day-tasks/next-day';
import {CompleteNotesPage} from '../complete-notes/complete-notes';
import {Badge} from '@ionic-native/badge';
import {InAppBrowser} from '@ionic-native/in-app-browser';
import {StorageService} from '../../providers/storage-service'

@Pipe({name: 'keys', pure: false})
export class HomeKeysPipe implements PipeTransform {
    transform(value: any, args: any[] = null): any {
        return Object.keys(value)//.map(key => value[key]);
    }
}

@Component({
    selector: 'page-home',
    templateUrl: 'home.html',
    animations: [
        Animations.expandCollapse
    ]
})

export class HomePage {
    @ViewChild('ctsNav') nav: NavController;
    @ViewChild(Content) content: Content;

    currentTask: any = '';
    currentUser: any = '';
    data: any;
    hideMoreProject: boolean = true;
    divState: string = 'hide';
    newStart: any = '';
    isIos: boolean = false;
    isAndroid: boolean = false;
    lat: any;
    lon: any;
    desktop: boolean = false;
    iosTime: any = '';
    iosDay: any = '';
    iosMonth: any = '';
    iosYear: any;
    androidVersion: any;
    compName: any;
    myData: any = {};
    showTasks = false;
    userRole: number = 0;
    laborerTasks: any = '';
    expandTaskId: number = -1;
    taskId: number = -1;
    myAlerts: number = 0;
    myFirstKey: any;
    timecardStatus: number;
    showTimecard: boolean = false;
    isLessor: boolean = false;


    constructor(public navCtrl: NavController,
                public push: Push,
                public taskMgr: TaskManager,
                public plt: Platform,
                private mapsManager: GoogleMapsManager,
                private userMgr: UserManager,
                private appCtrl: App,
                private geolocation: Geolocation,
                private utils: Utils,
                private callNumber: CallNumber,
                private androidFullScreen: AndroidFullScreen,
                private diagnostic: Diagnostic,
                public badge: Badge,
                private iab: InAppBrowser,
                private _backBtn: HardwareBackButtonService,
                private storage: StorageService,
                private alertCtrl: AlertController) {

        this.currentUser = this.userMgr.getUser();
        console.log('this.currentUser', JSON.stringify(this.currentUser));
        this.userRole = this.currentUser.role_id;
        if (this.currentUser.is_lessor === 1) {
            this.isLessor = true;
        }
        console.log('isLessor', JSON.stringify(this.isLessor));


        if (this.plt.is('core')) {
            this.desktop = true;
        }

        if (this.plt.is('ios')) {
            this.isIos = true;
        }

        if (this.plt.is('android')) {
            this.isAndroid = true;
            this.androidVersion = this.plt.version();
            this.androidFullScreen.isImmersiveModeSupported()
                .then(() => this.androidFullScreen.immersiveMode())
                .catch((error: any) => console.log(error));
        }

        this.hideMoreProject = true;
        this.divState = 'collapse';

        // *
        // Push Notifications
        // *
        if ((this.isIos || this.isAndroid) && this.currentUser.role_id !== 6) {
            this.push.register().then((t: PushToken) => {
                return this.push.saveToken(t);
            }).then((t: PushToken) => {
                this.taskMgr.updateEmployeeToken(t.token).then(response => {
                });
            });

            this.push.rx.notification()
                .subscribe((data: any) => {
                        console.log('data', JSON.stringify(data));
                        this.navCtrl.push(AlertsPage, {message: data.message})
                    }
                );
        }
    }

// helper method for the expand/collapse div animation
    toggleDivState() {
        let states = {
            expand: 'collapse',
            collapse: 'expand'
        };
        this.divState = states[this.divState];
    }

    ionViewDidLoad() {
        console.log('View is loaded');
    }

    ionViewDidEnter() {
        console.log('HomePage View is entered');
        this.currentUser = this.userMgr.getUser();
        if (this.userRole === 6) {
            this.loadLaborersTasks();
        } else {
            this.setCurrentTask(true);
            setTimeout(() => this.taskMgr.checkEmployeeAlerts(), 1500);
            setTimeout(() => {
                this.setBadges()
            }, 3000)
        }
        this._backBtn.registerAction(() => {
            this._backBtn.doubleBackToExit();
        }, 101);
        this.setLocation();
        setTimeout(() => this.setCompany(), 500);
        this.checkTimecardStatus();

    }

// /** logs the user out of the app */
    logout() {

        if (this.timecardStatus === 1) {
            let alert = this.alertCtrl.create({
                title: 'Timecard Alert!',
                cssClass: 'myAlerts',
                message: 'You are currently clocked in. Please clock out before logging out.',
                buttons: ['OK']
            });
            alert.present();
        }
        else {
            this.userMgr.logout().then(response => {
                this.appCtrl.getRootNav().push(LoginPage);
            })
        }
    }

    setBadges() {
        this.taskMgr.checkEmployeeAlerts().then((res: any) => {
            console.log('res', JSON.stringify(res));
            this.myAlerts = res.data.new_alert_count;
            console.log('this.myAlerts', JSON.stringify(this.myAlerts));
            let badges = this.badge.set(this.myAlerts);
        });
        this.requestPermission();
    }

    requestPermission() {
        let hasPermission = this.badge.hasPermission();
        if (!hasPermission) {
            let permission = this.badge.registerPermission();
        }
    }

    setCompany() {
        let holdingObject: any;
        holdingObject = this.currentUser;
        this.compName = holdingObject.company_name;
    }

    setLocation() {
        let locEnabled: boolean = false;

        let successCallback = (isAvailable) => {
            if (isAvailable) {
                locEnabled = true;
                return locEnabled;
            } else {
                this.utils.presentToast("Unable to get a precise location. Some functionality will be limited until device location is available", true);
                return;
            }
        };
        let errorCallback = (e) => {
            this.utils.presentToast("Please verify that your location settings are turned on", true);
        }
        this.diagnostic.isLocationEnabled().then(successCallback).then(resp => {
            if (locEnabled) {
                this.geolocation.getCurrentPosition({timeout: 20000}).then(position => {
                    this.lat = position.coords.latitude;
                    this.lon = position.coords.longitude;
                }).catch((error) => {
                    this.utils.presentToast('Unable to get a precise location. Some functionality will be limited until device location is available', true, '', 10000);
                });
            }
        }).catch(errorCallback);
    }

// sets the status of the task using TaskManager
// then loads the current task from the API
    setStatus = (statusId: number, notes?: any, showLoading?: boolean): void => {
        showLoading = showLoading || false;
        console.log("step 2 Set Status: " + statusId);
        if (statusId === 3) {
            let data = this.dataFunction(notes, statusId);

            if (showLoading) {
                console.log("1 loading");
                this.utils.presentLoading();
            }

            this.taskMgr.updateTaskStatus(data).then((response) => {
                this.setCurrentTask(true);
            }).catch(error => {
                console.log(`ERROR: ${Utils.toJson(error)}`);
                console.log("error " + error);
                this.utils.dismissLoading();
            });
        } else if (
            statusId === 4 ||
            statusId === 5 ||
            statusId === 6 ||
            statusId === 7 ||
            statusId === 9 ||
            statusId === 10 ||
            statusId === 13) {

            console.log("step 2a " + statusId);
            console.log('this.desktop', JSON.stringify(this.desktop));
            console.log("2 loading")
            if (showLoading) {
                console.log("2 loading");
                this.utils.presentLoading();
            }
            if (this.desktop) {
                let data = this.dataFunction(notes, statusId, null, null);
                console.log("step 3 data = " + data);
                if (data.statusId === 6 || data.statusId === 9) {
                    this.showTasks = false;
                    this.taskMgr.updateTaskStatus(data).then((response) => {
                        this.setCurrentTask(false);
                    }).catch(error => {
                        console.log(`ERROR: ${Utils.toJson(error)}`);
                        console.log("error " + error);
                    });
                }
                else if (data.statusId < 8 || data.statusId === 10 || data.statusId === 13) {
                    console.log("step 4 - else if " + data.statusId);

                    this.taskMgr.updateTaskStatus(data).then((response) => {
                        this.setCurrentTask(false);
                    }).catch(error => {
                        console.log("error " + error);
                    });
                }
            }
            else {
                this.geolocation.getCurrentPosition({timeout: 2000}).then(position => {
                    this.lat = position.coords.latitude;
                    this.lon = position.coords.longitude;
                    let data = this.dataFunction(notes, statusId, this.lat, this.lon);
                    console.log("step 3a data = " + data);
                    if (data.statusId === 6 || data.statusId === 9) {
                        this.showTasks = false;
                        this.taskMgr.updateTaskStatus(data).then((response) => {
                            this.setCurrentTask(false);
                        }).catch(error => {
                            console.log("error " + error);
                        });
                    }
                    else if (data.statusId < 8 || data.statusId === 10 || data.statusId === 13) {
                        console.log("step 4 - else if " + data.statusId);
                        this.taskMgr.updateTaskStatus(data).then((response) => {
                            this.setCurrentTask(false);
                        }).catch(error => {
                            console.log("error " + error);
                        });
                    }
                }).catch((error) => {
                    let data = this.dataFunction(notes, statusId, 'GPS Turned Off', 'GPS Turned Off');
                    if (data.statusId === 6 || data.statusId === 9) {
                        this.showTasks = false;
                        this.taskMgr.updateTaskStatus(data).then((response) => {
                            this.setCurrentTask(false);
                        }).catch(error => {
                            console.log("error " + error);
                        });
                    }
                    else if (data.statusId < 8 || data.statusId === 10 || data.statusId === 13) {
                        this.taskMgr.updateTaskStatus(data).then((response) => {
                            this.setCurrentTask(false);
                        }).catch(error => {
                            console.log("error " + error);
                        });
                    }
                });
            }
        }
        else if (statusId === 8) {
            let data = this.dataFunction(notes, statusId);
            this.taskMgr.updateTaskStatus(data).then((response) => {
                this.showTasks = false;
                this.setCurrentTask(false);
            }).catch(error => {
                console.log("error " + error);
            });
        }
    };

// function to replace writing this logic multiple times in this.setStatus
    dataFunction(notes: any, statusId: number, lat ?: any, lon ?: any) {
        if (lat) {
            this.myData = {
                notes: notes || '',
                statusId: statusId,
                files: [],
                lat: lat,
                lon: lon,
                timestamp: new Date(Date.now())
            }
        } else {
            this.myData = {
                notes: notes || '',
                statusId: statusId,
                files: [],
                timestamp: new Date(Date.now())
            }
        }
        return this.myData;
    }

// sets the current task
// @Param: optional showLoading:boolean show we show a loading spinner?
    setCurrentTask(showLoading ?: boolean) {

        this.currentUser = this.userMgr.getUser();

        let today = new Date(Date.now());
        today.toDateString();

        showLoading = showLoading || false;
        if (showLoading) {
            console.log("3 loading");
            this.utils.presentLoading();
        }
        this.taskMgr.getCurrentTaskRemote().then(response => {
            this.utils.dismissLoading();
            this.data = response;
            this.currentTask = this.data.task;
            this.currentUser = this.data.user;
            if (this.currentTask === []) {
                this.showTasks = false;
            } else if (
                this.currentTask.job_tasks.status_id === 2 ||
                this.currentTask.job_tasks.status_id === 3 ||
                this.currentTask.job_tasks.status_id === 4 ||
                this.currentTask.job_tasks.status_id === 5 ||
                this.currentTask.job_tasks.status_id === 7 ||
                this.currentTask.job_tasks.status_id === 13) {
                this.newStart = this.currentTask.job_tasks.task_start_time + ' ' + this.currentTask.job_tasks.task_date;
                this.showTasks = true;
                let combined = this.newStart[0] + '' + this.newStart[1];
                let combinedInt = parseInt(combined);

                // Code to fix how the time shows up, it has been compressed to save room

                if (combinedInt > 12) {
                    combinedInt -= 12;
                    this.iosTime = combinedInt + ':' + this.newStart[3] + this.newStart[4] + ' ' + 'PM';
                }
                else if (combinedInt === 12) {
                    this.iosTime = combinedInt + ':' + this.newStart[3] + this.newStart[4] + ' ' + 'PM';
                }
                else if (combinedInt > 9 && combinedInt < 12) {
                    this.iosTime = combinedInt + ':' + this.newStart[3] + this.newStart[4] + ' ' + 'AM';
                }
                else if (combinedInt < 10) {
                    let morning = this.newStart[1];
                    this.iosTime = morning + ':' + this.newStart[3] + this.newStart[4] + ' ' + 'AM';
                }
                let month = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                let taskMonth = this.currentTask.job_tasks.task_date[5] + '' + this.currentTask.job_tasks.task_date[6];
                let taskMonthInt = parseInt(taskMonth);
                this.iosMonth = month[taskMonthInt - 1];
                this.iosYear = this.currentTask.job_tasks.task_date[0] + '' + this.currentTask.job_tasks.task_date[1] + '' + this.currentTask.job_tasks.task_date[2] + '' + this.currentTask.job_tasks.task_date[3];
                this.iosDay = this.currentTask.job_tasks.task_date[8] + '' + this.currentTask.job_tasks.task_date[9];

                if (this.userRole === 1 || this.userRole === 2 || this.userRole === 4) {
                    this.content.scrollTo(0, 79, 300).then(res => {
                        console.log('res', JSON.stringify(res));
                    });
                }
                console.log('this.currentTask', JSON.stringify(this.currentTask));
            }
            else if (this.currentTask.job_tasks.status_id === 8) {
                this.showTasks = false;
            }
            else if (this.currentTask.job_tasks.status_id === 9 || this.currentTask.job_tasks.status_id === 6) {
                this.taskMgr.getCurrentTaskRemote().then(response => {
                    this.data = response;
                    this.currentTask = this.data.task;
                    this.currentUser = this.data.user;
                })
            }
        })
            .catch(error => {
                error = error || {error: 'is undefined'};
                this.showTasks = false;
                this.utils.dismissLoading();
                setTimeout(() => {
                    // console.log("error " + error);
                    if (!this.currentTask.id) {
                        this.showTasks = false;
                    }
                }, 2500)
            })
    }


// gets the directions, passes the directions as a param to
// the driving directions page
    showDrivingDirections(lat, lon) {
        console.log("4 loading");
        this.utils.presentLoading();
        let locEnabled: boolean = false;

        let successCallback = (isAvailable) => {
            console.log('9');
            if (isAvailable) {
                locEnabled = true;
                return locEnabled;
            } else {
                console.log('10');
                this.utils.presentToast("Please verify that your location is turned on in your device settings", true);
                return;
            }
        };
        let errorCallback = (e) => {
            this.utils.presentToast("Please verify that your location is turned on in your device settings", true);
            this.utils.dismissLoading();
        }

        this.diagnostic.isLocationEnabled().then(successCallback).then(resp => {
            console.log('11');
            if (locEnabled) {
                console.log('12');
                let destination = `${lat},${lon}`;
                this.geolocation.getCurrentPosition({timeout: 15000}).then((position) => {
                    let origin = `${position.coords.latitude},${position.coords.longitude}`;
                    return this.mapsManager.getDirections(origin, destination);
                }).then((response) => {
                    let params = {
                        directions: response
                    };
                    setTimeout(() => {
                        this.navCtrl.push(DrivingDirectionsPage, params);
                        this.utils.dismissLoading();
                    }, 2000)
                }).catch((error) => {
                    console.log('13');
                    this.utils.dismissLoading();
                    console.log(`ERROR: ${Utils.toJson(error)}`);
                    this.utils.presentToast("Please3 verify that your location is turned on in your device settings", true);
                })
            }
            if (locEnabled === false) {
                console.log('14');
                this.utils.dismissLoading();
            }
        }).catch(errorCallback);
    }

// opens the reject task modal, handles the data passed back from the modal
    openRejectModal() {
        let modal: Modal = this.utils.presentRejectNotesModal();
        modal.onDidDismiss((data) => {
            if (data.save === true) {
                this.setStatus(8, data.notes);
            }
        })
    }

    openCompletePage() {
        this.navCtrl.push(CompleteNotesPage);
        return true;
    }


// does not open a modal as the name might suggest.
// Instead it navigates to a page
    openFeedbackModal() {
        this.navCtrl.push(FeedbackPage);
        return true;
    }

    openNextDayTasks() {
        this.navCtrl.push(NextDayPage).then(response => {
            console.log('response', JSON.stringify(response));
        });
        return true;
    }

// laborer functions
    loadLaborersTasks() {
        console.log("5 loading");
        this.utils.presentLoading();
        this.taskMgr.loadLaborerTasks(this.currentUser.userId).then((response: any) => {
            if (response.data === []) {
                this.showTasks = false;
                this.utils.dismissLoading();
            }
            else {
                this.laborerTasks = response;
                this.myFirstKey = this.laborerTasks.data[Object.keys(this.laborerTasks.data)[0]];
                if (this.myFirstKey === undefined) {
                    this.showTasks = false;
                    this.utils.dismissLoading();
                }
                else {
                    this.showTasks = true;


                    let firstKey = this.laborerTasks.data[Object.keys(this.laborerTasks.data)[0]];
                    console.log('firstKey before sort ', JSON.stringify(firstKey));

                    for (let j = 0; j < firstKey.length; j++) {
                        firstKey[j].newStart = firstKey[j].task_start_time;
                        let combined = firstKey[j].newStart[0] + '' + firstKey[j].newStart[1];
                        let combinedInt = parseInt(combined);
                        let newTime: string;
                        if (combinedInt > 12) {
                            combinedInt -= 12;
                            newTime = combinedInt + ':' + firstKey[j].newStart[3] + firstKey[j].newStart[4] + ' ' + 'PM';
                        } else if (combinedInt > 9 && combinedInt <= 12) {
                            newTime = combinedInt + ':' + firstKey[j].newStart[3] + firstKey[j].newStart[4] + ' ' + 'AM';
                        } else if (combinedInt < 10) {
                            let morning = firstKey[j].newStart[1];
                            newTime = morning + ':' + firstKey[j].newStart[3] + firstKey[j].newStart[4] + ' ' + 'AM';
                        }
                        firstKey[j].newTime = newTime;
                        this.laborerTasks.data[Object.keys(this.laborerTasks.data)[0]][j].newTime = newTime;
                    }
                    firstKey.sort(function (a, b) {
                        return (a.task_start_time > b.task_start_time) ? 1 : ((b.task_start_time > a.task_start_time) ? -1 : 0);
                    });

                    console.log('firstKey after sort ', JSON.stringify(firstKey));

                    this.utils.dismissLoading();
                }
            }
        })
    }

    setLaborerStatus = (statusId: number, taskId: number, dateKey: string, taskIndex: number, notes?: any): void => {
        if (statusId === 3) {
            this.laborerTasks.data[dateKey][taskIndex].status_id = 3;
            let data = {
                notes: notes || '',
                statusId: statusId,
                files: [],
                timestamp: new Date(Date.now()),
                taskId: taskId
            };
            console.log("6 loading");
            this.utils.presentLoading();
            this.taskMgr.updateNextDayTaskStatus(data).then((response) => {
                this.utils.dismissLoading();
            }).catch(error => {
                console.log(`ERROR: ${Utils.toJson(error)}`);
                console.log("error " + error);
                this.utils.dismissLoading();
            });
        } else if (statusId === 8) {
            this.laborerTasks.data[dateKey][taskIndex].status_id = 8;
            let data = {
                notes: notes || '',
                statusId: statusId,
                files: [],
                timestamp: new Date(Date.now()),
                taskId: taskId
            };
            console.log("7 loading");
            this.utils.presentLoading();
            this.taskMgr.updateNextDayTaskStatus(data).then((response) => {
                this.utils.dismissLoading();
            }).catch(error => {
                console.log(`ERROR: ${Utils.toJson(error)}`);
                console.log("error " + error);
                this.utils.dismissLoading();
            });
        }
    };

    openLaborerRejectModal(statusId: number, taskId: number, dateKey: string, taskIndex: number, notes ?: any) {
        let modal: Modal = this.utils.presentRejectNotesModal();
        modal.onDidDismiss((data) => {
            if (data.save === true) {
                this.setLaborerStatus(statusId, taskId, dateKey, taskIndex, data.notes);
            }
        })
    }

    expandTask(id, index) {
        if (this.expandTaskId === id && this.taskId === index) {
            if (!this.isIos) {
                this.content.scrollTo(0, 0, 300).then(res => {
                    console.log('res', JSON.stringify(res));
                });
            }
            this.expandTaskId = -1;
            this.taskId = -1;
        } else {
            if (!this.isIos) {
                this.content.scrollTo(0, ((index * 50) + 85), 300).then(res => {
                    console.log('res', JSON.stringify(res));
                });
            }
            this.expandTaskId = id;
            this.taskId = index;
        }
    }

    callPhone(number) {
        this.callNumber.callNumber(number, false)
            .then(() => console.log('Launched dialer!'))
            .catch(() => console.log('Error launching dialer'));
    }

    openInAppBrowser() {
        let options = "location=no";
        this.iab.create("https://www.cleartasksolutions.com/app/login/index.html", "_system", options);
    }

    createTimecardEntry(status) {

        console.log('status type ' + typeof status);

        console.log('this.showTasks', JSON.stringify(this.showTasks));

        if (this.showTasks) {


            if (status === 0 && this.currentTask.job_tasks.status_id === 4) {
                console.log("Step 1 status: " + status);
                let newNotes = "Clocked out while task was started";
                this.setStatus(13, newNotes, false)
            }

            if (status === 1 && this.currentTask.job_tasks.status_id === 13) {
                console.log("Step one status: " + status);
                let newNotes = "Clocked in, resumed task";
                this.setStatus(4, newNotes, false)
            }
        }

        console.log("8 loading");
        this.utils.presentLoading();

        let locEnabled: boolean = false;

        let successCallback = (isAvailable) => {
            console.log('isAvailable', JSON.stringify(isAvailable));
            if (isAvailable) {
                locEnabled = true;
                return locEnabled;
            } else {
                this.utils.presentToast("Unable to get a precise location. Some functionality will be limited until device location is available", true);

            }
        };
        let errorCallback = (e) => {
            let lat = null;
                let lon = null;

                this.taskMgr.createTimecardEntry(this.currentUser.userId, lat, lon, status).then(res => {
                    console.log('res in timecard', JSON.stringify(res));
                    this.timecardStatus = status;
                    this.storage.update("timecardStatus", status).then(res => {
                        console.log('res after clocking in or out ', JSON.stringify(res));
                    });
                    this.showTimecard = false;
                    this.utils.dismissLoading();
                })
            this.utils.presentToast("Please verify that your location settings are turned on", true);
        };
        this.diagnostic.isLocationEnabled().then(successCallback).then(resp => {
            if (locEnabled) {
                this.geolocation.getCurrentPosition({timeout: 20000}).then(position => {
                    this.lat = position.coords.latitude;
                    this.lon = position.coords.longitude;

                    this.taskMgr.createTimecardEntry(this.currentUser.userId, this.lat, this.lon, status).then(res => {
                        console.log('res in timecard', JSON.stringify(res));
                        this.timecardStatus = status;
                        this.storage.update("timecardStatus", status).then(res => {
                            console.log('res after clocking in or out ', JSON.stringify(res));
                        });
                        this.showTimecard = false;
                        this.utils.dismissLoading();
                    })

                }).catch((error) => {
                    this.utils.dismissLoading();
                    this.utils.presentToast('Unable to get a precise location. Some functionality will be limited until device location is available', true, '', 10000);
                });
            }

        }).catch(errorCallback);

        this.utils.dismissLoading();

    }

    checkTimecardStatus() {
        this.storage.get("timecardStatus").then(response => {
            this.timecardStatus = response;
            if (this.timecardStatus === null) {
                this.storage.add("timecardStatus", 0).then(res => {
                    this.timecardStatus = 0;
                })
            }
        });
    }

    showClockInOut() {
        this.showTimecard = !this.showTimecard;
    }

    showData() {
        console.log('this.showTasks', JSON.stringify(this.showTasks));
        // this.desktop = true;
        // console.log('this.currentTask', JSON.stringify(this.currentTask));
        // console.log('this.currentUser', JSON.stringify(this.currentUser));
        // let length = this.currentTask.job_tasks.task_user_log.length;
        // console.log('length', JSON.stringify(length));
        // let last = this.currentTask.job_tasks.task_user_log[length - 1];
        // console.log('last', JSON.stringify(last));
    }


}
