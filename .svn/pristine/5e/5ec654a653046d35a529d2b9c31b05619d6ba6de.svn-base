import {Component, ViewChild, Pipe, PipeTransform} from '@angular/core';
import {NavController, NavParams, Content, App, Platform, AlertController} from 'ionic-angular';
import {TaskManager} from '../../providers/task-manager';
import {Utils} from '../../utils/utils';
import {UserManager} from '../../providers/user-manager';
import {LoginPage} from '../login/login';

@Pipe({name: 'keys', pure: false})
export class TimecardKeysPipe implements PipeTransform {
    transform(value: any, args: any[] = null): any {
        return Object.keys(value)//.map(key => value[key]);
    }
}

@Component({
    selector: 'page-timecard',
    templateUrl: 'timecard.html'
})

export class TimecardPage {
    @ViewChild(Content) content: Content;


    isIos: boolean = false;
    userId: any = '';
    currentUser: any = '';
    todaysTime: any;
    startDate: any;
    endDate: any;
    prettyStart: any;
    prettyEnd: any;
    timecardHistory: any;
    currentDate: any;
    showCreateToday: boolean = false;
    newDayEntry: any = {
        notes: '',
        time: '12:00',
        status: ""
    };
    oldDayEntry: any = {
        notes: '',
        time: '12:00',
        status: ""
    };
    oldDayAndTimeEntry: any = {
        date: '2017-07-06',
        time: '12:00',
        status: '',
        notes: ''
    };
    showSearchResults: boolean = false;
    showCreateOld: boolean = false;
    addOldEntry: number = -1;


    constructor(public navCtrl: NavController,
                public navParams: NavParams,
                private userMgr: UserManager,
                private appCtrl: App,
                private taskMgr: TaskManager,
                public plt: Platform,
                private utils: Utils,
                private alertCtrl: AlertController) {

        this.currentUser = this.userMgr.getUser();
        this.userId = this.currentUser.userId;
        if (this.plt.is('ios')) {
            this.isIos = true;
        }
    }

    ionViewDidLoad() {
        console.log('ionViewDidLoad FeedbackPage');

    }

    ionViewDidEnter() {
    }

    ionViewWillLoad() {
        this.loadTodaysTime();
    }

    loadTodaysTime(test?: any) {
        this.utils.presentLoading();
        this.currentDate = new Date(Date.now()).toISOString().slice(0, 10);
        this.oldDayAndTimeEntry.date = this.currentDate;
        this.startDate = new Date(Date.now()).toISOString();
        this.endDate = new Date(Date.now()).toISOString();
        this.taskMgr.loadTodaysTime(this.userId).then((response: any) => {
            this.todaysTime = response.data;
            let dupArray = [];
            for (let i = 0; i < this.todaysTime.length; i++) {
                let newEntryYear = this.todaysTime[i].timestamp.slice(0, 10);
                let newEntryTime = this.todaysTime[i].timestamp.slice(11);
                this.todaysTime[i].timestamp = newEntryYear + 'T' + newEntryTime;

                if (this.todaysTime[i].alt_timestamp === null) {
                    this.todaysTime[i].alt_timestamp = this.todaysTime[i].timestamp;
                }
                if (this.todaysTime[i].notes === "NULL") {
                    this.todaysTime[i].notes = '';
                }
                this.todaysTime[i].originalNotes = this.todaysTime[i].notes;

                if (this.todaysTime[i].alt_timestamp) {
                    let newYear = this.todaysTime[i].alt_timestamp.slice(0, 10);
                    let newTime = this.todaysTime[i].alt_timestamp.slice(11);
                    this.todaysTime[i].alt_timestamp = newYear + 'T' + newTime;
                    this.todaysTime[i].timestamp = this.todaysTime[i].alt_timestamp;

                    let compareMonthAndDay = this.todaysTime[i].alt_timestamp[5] + '' + this.todaysTime[i].alt_timestamp[6] + '' + this.todaysTime[i].alt_timestamp[8] + '' + this.todaysTime[i].alt_timestamp[9];
                    let compareCurrentDay = this.currentDate[5] + '' + this.currentDate[6] + '' + this.currentDate[8] + '' + this.currentDate[9];

                    if (compareMonthAndDay === compareCurrentDay) {
                        dupArray.push(this.todaysTime[i]);
                    }
                }
            }
            this.todaysTime = dupArray;
            console.log('this.todaysTime', JSON.stringify(this.todaysTime));
            this.utils.dismissLoading();
        });
        this.showSearchResults = false;
    }

    updateTodaysTimecard(id, newTime, repeatIndex, notes: string) {
        let newNote = '';
        if (notes === '') {
            newNote = "NULL"
        } else {
            newNote = notes;
        }

        let newYear = newTime.slice(0, 10);
        let newestTime = newTime.slice(11, 19);
        let alt_timestamp = newYear + ' ' + newestTime;

        this.taskMgr.updateTimecard(this.userId, id, alt_timestamp, newNote).then((response: any) => {
            console.log('response in update ', JSON.stringify(response));
            this.todaysTime[repeatIndex].alt_timestamp = newTime;
            this.todaysTime[repeatIndex].timestamp = newTime;
            this.todaysTime[repeatIndex].notes = notes;
            this.todaysTime[repeatIndex].originalNotes = notes;
        })
    }

    dateConvert(date) {
        let months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
        let shortStart = date.slice(0, 10);
        let startYear = date.slice(0, 4);
        let startMonth = shortStart[5] + '' + shortStart[6];
        let parseStartMonth = parseInt(startMonth);
        let startDay = shortStart[8] + '' + shortStart[9];
        if (shortStart[8] === '0') {
            startDay = shortStart[9];
        }
        return (months[parseStartMonth - 1] + " " + startDay + ', ' + startYear);
    }

    timecardSearch() {
        this.utils.presentLoading();
        this.prettyStart = this.dateConvert(this.startDate);
        this.prettyEnd = this.dateConvert(this.endDate);
        let endDate = new Date(this.endDate);
        let endTime = endDate.getTime();
        let millisecondDate = endTime + 86400000;
        let convertBack = new Date(millisecondDate);

        this.taskMgr.timecardSearch(this.userId, this.startDate, convertBack).then((response: any) => {
                this.timecardHistory = response.data;
                let dupArray = [];
                for (let i = 0; i < this.timecardHistory.length; i++) {
                    if (this.timecardHistory[i].alt_timestamp === null) {
                        this.timecardHistory[i].alt_timestamp = this.timecardHistory[i].timestamp;
                    }
                    if (this.timecardHistory[i].alt_timestamp) {
                        let newYear = this.timecardHistory[i].alt_timestamp.slice(0, 10);
                        let newTime = this.timecardHistory[i].alt_timestamp.slice(11);
                        this.timecardHistory[i].alt_timestamp = newYear + 'T' + newTime;
                        this.timecardHistory[i].timestamp = this.timecardHistory[i].alt_timestamp;
                    }
                    if (this.timecardHistory[i].notes === "NULL") {
                        this.timecardHistory[i].notes = '';
                    }
                    this.timecardHistory[i].newDate = this.timecardHistory[i].timestamp.slice(0, 10);
                    let newYear = this.timecardHistory[i].timestamp.slice(0, 10);
                    let newTime = this.timecardHistory[i].timestamp.slice(11);
                    this.timecardHistory[i].timestamp = newYear + 'T' + newTime;
                    this.timecardHistory[i].originalNotes = this.timecardHistory[i].notes;
                    let intCompare = parseInt(this.timecardHistory[i].alt_timestamp[5] + '' + this.timecardHistory[i].alt_timestamp[6]);
                    let intStart = parseInt(this.startDate[5] + '' + this.startDate[6]);

                    if (intCompare >= intStart) {
                        dupArray.push(this.timecardHistory[i]);
                    }
                }
                this.timecardHistory = dupArray;
                this.timecardHistory.sort(function (a, b) {
                    return (a.alt_timestamp > b.alt_timestamp) ? 1 : ((b.alt_timestamp > a.alt_timestamp) ? -1 : 0);
                });
                this.timecardHistory = this.groupBy(this.timecardHistory, "newDate");

                if (this.todaysTime.length === 0) {
                    this.content.scrollTo(0, 171, 300).then(res => {
                        console.log('res', JSON.stringify(res));
                    })
                } else if (this.todaysTime.length >= 1) {
                    this.content.scrollTo(0, ((171 + (this.todaysTime.length * 110))), 300).then(res => {
                        console.log('res', JSON.stringify(res));
                    })
                }


                this.utils.dismissLoading();

            }
        );
        this.showSearchResults = true;
    }

    updateTimecardSearch(id, newTime, dateKey, entryIndex, notes: string) {
        let newNote = '';
        if (notes === '') {
            newNote = "NULL"
        } else {
            newNote = notes;
        }
        let newYear = newTime.slice(0, 10);
        let newestTime = newTime.slice(11, 19);
        let alt_timestamp = newYear + ' ' + newestTime;
        this.taskMgr.updateTimecard(this.userId, id, alt_timestamp, newNote).then((response: any) => {
            if (response.code === 0) {
                this.timecardHistory[dateKey][entryIndex].alt_timestamp = newTime;
                this.timecardHistory[dateKey][entryIndex].timestamp = newTime;
                this.timecardHistory[dateKey][entryIndex].notes = notes;
                this.timecardHistory[dateKey][entryIndex].originalNotes = notes;
            }
        })
    }

    // function to sort timecard data into their individual days
    groupBy(array, property) {
        let hash = {};
        for (let i = 0; i < array.length; i++) {
            if (!hash[array[i][property]]) hash[array[i][property]] = [];
            hash[array[i][property]].push(array[i]);
        }
        return hash;
    }

    createNewEntry(object, date, altTime, status, notes) {
        let myStatusInt: number;
        if (status === '0') {
            myStatusInt = 0;
        } else {
            myStatusInt = 1;
        }
        let combinedDate = date + ' ' + altTime;

        this.taskMgr.createNewTimecardEntry(this.userId, status, combinedDate, notes).then(response => {
            this.showCreateToday = false;
            let newAltComplete = this.currentDate + 'T' + altTime;

            let newEntry = {
                "timestamp": newAltComplete,
                "notes": notes,
                "alt_timestamp": newAltComplete,
                "status": myStatusInt,
                "active": 1,
                "originalNotes": notes
            };
            this.todaysTime.push(newEntry);
            this.newDayEntry = {
                notes: '',
                time: '12:00',
                status: ""
            };
            this.todaysTime.sort(function (a, b) {
                return (a.alt_timestamp > b.alt_timestamp) ? 1 : ((b.alt_timestamp > a.alt_timestamp) ? -1 : 0);
            });
        })
    }

    deleteEntry(entryObject, index, date?: any) {
        this.taskMgr.deleteTimecardEntry(this.userId, entryObject.id).then((response: any) => {
            if (response.code === 0 && !date) {
                this.todaysTime.splice(index, 1);
            }
            else if (response.code === 0 && date) {
                this.timecardHistory[date].splice(index, 1);
            }
        })
    }

    presentConfirm(entryObject, index, date?: any) {
        let alert = this.alertCtrl.create({
            title: 'Confirm Delete',
            message: 'Do you want to delete this entry from your timecard?',
            cssClass: 'deleteEntry',
            buttons: [
                {
                    text: 'Cancel',
                    role: 'cancel',
                    handler: () => {
                        console.log('Cancel clicked');
                    }
                },
                {
                    text: 'Delete',
                    handler: () => {
                        this.deleteEntry(entryObject, index, date);
                    }
                }
            ]
        });
        alert.present();
    }

    createOldEntry(key, status, time, notes?: any) {
        time += ":00";
        let alt_timestamp = key + " " + time;
        this.taskMgr.createNewTimecardEntry(this.userId, status, alt_timestamp, notes).then((response: any) => {
            this.addOldEntry = -1;
            this.timecardSearch();
        })
    }

    createDayAndTime(date, time, status, notes?: any) {

        let alt_timestamp = date + " " + time;
        this.taskMgr.createNewTimecardEntry(this.userId, status, alt_timestamp, notes).then((response: any) => {
            this.timecardSearch();
            this.oldDayAndTimeEntry = {
                date: this.currentDate,
                time: '12:00',
                status: '',
                notes: ''
            }
        })
    }

    showNewEntryCreation() {
        this.showCreateToday = true;
    }

    showOldEntryCreation(index) {
        if (this.addOldEntry === -1 || this.addOldEntry !== index) {
            this.addOldEntry = index;
            this.oldDayEntry = {
                notes: '',
                time: '12:00',
                status: ""
            };
        }
        this.showCreateOld = true;
    }

    cancelNewDayEntry() {
        this.addOldEntry = -1;
        this.showCreateOld = false;
        this.oldDayAndTimeEntry = {
            date: '2017-07-06',
            time: '12:00',
            status: '',
            notes: ''
        };
    }

    cancelOldEntry() {
        this.addOldEntry = -1;
        this.showCreateOld = false;
        this.oldDayEntry = {
            notes: '',
            time: '12:00',
            status: ""
        };
    }

    cancelEntry() {
        this.showCreateToday = false;
        this.newDayEntry = {
            notes: '',
            time: '12:00',
            status: ""
        };
    }

    logout() {
        this.userMgr.logout().then(response => {
            this.appCtrl.getRootNav().push(LoginPage);
        })
    }

    disableNewDay() {
        return this.oldDayAndTimeEntry.status.trim().length < 1;
    }

    disableOldEntry() {
        return this.oldDayEntry.status.trim().length < 1;
    }

    disableCurrentEntry() {
        return this.newDayEntry.status.trim().length < 1;
    }
}
